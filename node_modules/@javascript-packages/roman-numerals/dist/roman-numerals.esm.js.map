{"version":3,"file":"roman-numerals.esm.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * A pair consisting of Roman numerals and their numeric value.\n */\nexport type Roman = {\n  value: number;\n  numerals: string;\n};\n\n/**\n * Converts an integer to a Roman numeral.\n *\n * @param number An integer. Must be in range [1, 4999].\n * @returns Roman numeral.\n * @throws {RangeError} Argument number must be non-negative.\n * @throws {RangeError} Argument number must be non-zero.\n * @throws {RangeError} Argument number must be less than or equal to 4999.\n */\nexport const toRoman = (number: number) => {\n  const recurse = (\n    number: number,\n    stack: Array<Roman>,\n    roman = ''\n  ): Roman['numerals'] => {\n    // No negatives.\n    if (number < 0) {\n      throw new RangeError(`(arg): number must be non-negativ.`);\n    }\n\n    // No zero.\n    if (number === 0) {\n      throw new RangeError(`(arg): number must not be zero.`);\n    }\n\n    // No numbers outside interval [1, 4999].\n    if (number > 4999) {\n      throw new RangeError(`(arg): number must be less than or equal to 4999.`);\n    }\n\n    // The stack contains all the numerals available,\n    // greatest on the top. The stack also includes\n    // the values of \"composite numerals\" - pairs of\n    // numerals that follow the subtractive rule,\n    // e. g. 4 (IV), 9 (IX) and 40 (XL).\n    const { value: largest, numerals } = stack.shift()!;\n\n    // Each iteration checks how many times the number\n    // on top of the stack is divisible by the number\n    // to be converted.\n    const quotient = Math.floor(number / largest);\n\n    // Then, a portion of the Roman numeral sequence\n    // can be generated by looking up the corresponding\n    // Roman numerals and repeating as many times as the\n    // number to be converted is divisible by the largest\n    // number in the stack.\n    roman = `${roman}${numerals.repeat(quotient)}`;\n\n    // In the next iteration, the current remainder of the\n    // division corresponds to the number that is to be\n    // converted into a Roman numeral.\n    const remainder = number % largest;\n\n    // Finally, the division remainder (new number to be\n    // converted) is passed recursively with the stack\n    // whose largest element was removed.\n    // However, if the remainder of the division is zero,\n    // the recursion is terminated and the Roman numeral\n    // has been found.\n    return remainder === 0 ? roman : recurse(remainder, stack, roman);\n  };\n\n  // The list of all available Roman numerals, beginning\n  // with the largest.\n  const stack: Array<Roman> = [];\n\n  stack.push({ value: 1000, numerals: 'M' });\n  stack.push({ value: 900, numerals: 'CM' });\n  stack.push({ value: 500, numerals: 'D' });\n  stack.push({ value: 400, numerals: 'CD' });\n  stack.push({ value: 100, numerals: 'C' });\n  stack.push({ value: 90, numerals: 'XC' });\n  stack.push({ value: 50, numerals: 'L' });\n  stack.push({ value: 40, numerals: 'XL' });\n  stack.push({ value: 10, numerals: 'X' });\n  stack.push({ value: 9, numerals: 'IX' });\n  stack.push({ value: 5, numerals: 'V' });\n  stack.push({ value: 4, numerals: 'IV' });\n  stack.push({ value: 1, numerals: 'I' });\n\n  return recurse(number, stack);\n};\n"],"names":["toRoman","number","recurse","stack","roman","RangeError","shift","largest","value","numerals","quotient","Math","floor","repeat","remainder","push"],"mappings":"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"}